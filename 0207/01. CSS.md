[TOC]

# CSS

> 스타일, 레이아웃 등을 통해 HTML이 사용자에게 어떻게 표시 되는지를 지정하는 언어
>
> 사용자에게 문서(HTML)를 표시하는 방법을 지정하는 언어

<br>

## CSS 구문

- 구문은 **선택자**와 함께 열린다. (스타일을 지정할 html 요소를 선택. )
- 다음 중괄호가 있는데 이 안에는 속성과 값 쌍 형태를 가지는 하나 또는 그 이상의 선언(declaration)이 있다. 
- 각 쌍은 우리가 선택한 요소의 속성을 지정하고 속성에 부여할 값을 지정한다.



![제목 없음4](CSS.assets/제목 없음4-1612252194504.png)

<br>

**선언문** 

- **속성** (Property)
  - 사람이 읽을 수 있는 식별자로, 어떤 (글꼴, 너비, 배경색 등) 스타일 기능을 변경할지 나타냅니다.
- **값** (Value)
  - 각 속성에는 값을 부여한다.
  - 값은 어떻게 (글꼴을 이걸로, 배경 색을 저걸로 등)스타일 기능을 변경할 건지 나타낸다.

<br>

## CSS 선택자(selector)

>  스타일을 적용할 HTML 요소를 선택하는데 사용하는 선택자

 

대표적인 선택자

\- HTML 요소 선택자

\- 아이디(id) 선택자

\- 클래스(class) 선택자



#### CSS 선택자 - 1. HTML 요소 선택자

> HTML 요소의 이름을 직접 사용

```html
<style>
    h2 { color: teal; text-decoration: underline; }
</style>
...
<h2>이 부분에 스타일을 적용합니다.</h2>
```



#### CSS 선택자 - 2. id 선택자

```html
<style>
    #heading { color: sandybrown; text-decoration: line-through; }
</style>
...
<h2 id="heading">이 부분에 스타일을 적용합니다.</h2>
```



#### CSS 선택자 - 3. class 선택자

> 특정 집단의 여러 요소를 한 번에 선택할 때 사용

```html
<style>
    .headings { color: deepskyblue; text-decoration: overline; }
</style>
...
<h2 class="headings">이 부분에 스타일을 적용합니다.</h2>
<p>클래스 선택자를 이용하여 스타일을 적용할 HTML 요소들을 한 번에 선택할 수 있습니다.</p>
<h3 class="headings">이 부분에도 같은 스타일을 적용합니다.</h3>
```



#### CSS 선택자 - 4. 그룹 선택자

> 위에서 언급한 여러 선택자를 같이 사용하고자 할 때 사용
>
> 여러 선택자를 쉼표(,)로 구분하여 연결
>
> 코드를 간결하게 만들어 주는 용도

```html
<style>
    h2 { color: navy; }
    h2, h3 { text-align: center; }
    h2, h3, p { background-color: lightgray; }
</style>
```



## 결합 선택자

> 결합 선택자는 연관된 선택자들 간의 관계를 설정해줌



#### 결합 선택자 - 1. 자손 선택자

> 해당 요소의 하위 요소 중에서 특정 타입의 요소를 모두 선택

```css
/*모든 <div>태그의 하위 요소 중에서 <p>태그를 모두 선택*/
<style>
	div p {스타일;}
</style>
```



#### 결합 선택자 - 2. 자식 선택자

> 해당 요소의 바로 밑에 존재하는 하위 요소 중에서 특정 타입의 요소를 모두 선택

```css
/*모든 <div>태그의 바로 밑에 존재하는 하위 요소 중에서 <p>태그를 모두 선택*/
<style>
    div > p { background-color: #FFEFD5; }
</style>
```



## 구조 의사 클래스

#### :nth-child

> 모든 자식(child) 요소 중에서 앞에서부터 n번째에 위치하는 자식(child) 요소를 모두 선택



![image-20210206171715709](01. CSS.assets/image-20210206171715709.png)

여기서 만약 p:nth-child(`2`) 라 바꿔주면, 두 번째 `<p>`태그의 글자만 굵고 빨갛게 바뀐다.



#### :nth-of-type

> 모든 자식(child) 요소 중에서 n번째로 등장하는 특정 타입의 요소를 모두 선택

![image-20210206172335463](01. CSS.assets/image-20210206172335463.png)



## 네비게이션 바

> 우리가 흔히 사용하는 웹 사이트의 메뉴를 의미



#### 링크를 사용한 리스트 메뉴

> 네비게이션 바 중 가장 기본적인 것이 바로 링크(link)를 사용한 리스트 메뉴

```css
<ul>
    <li><a href="/index.php">Home</a></li>
    <li><a href="/html/intro">HTML</a></li>
    <li><a href="/css/intro">CSS</a></li>
    <li><a href="/javascript/intro">자바스크립트</a></li>
</ul>
```



<img src="01. CSS.assets/image-20210206173034816.png" alt="image-20210206173034816" style="zoom:50%;" />

#### 수직 내비게이션 바

> display 속성값을 **block**으로 설정하면, 간단히 수직 내비게이션 바를 만들 수 있음

```css
<head>
	<meta charset="UTF-8">
	<title>CSS Structural Selectors</title>
	<style>
		li {

      display: block;
		}
	</style>
</head>

<body>
  <ul>
    <li><a href="#">Home</a></li>
    <li><a href="#">Login</a></li>
  </ul>
</body>
```



![image-20210206174242012](01. CSS.assets/image-20210206174242012.png)



#### 수평 내비게이션 바

> display 속성값을 **inline**으로 설정하면, 간단히 수평 내비게이션 바를 만들 수 있음

```css

<head>
	<meta charset="UTF-8">
	<title>CSS Structural Selectors</title>
	<style>
		li {
      display: inline;
		}
	</style>
</head>

<body>
  <ul>
    <li><a href="#">Home</a></li>
    <li><a href="#">Login</a></li>
  </ul>
</body>
```

![image-20210206174355645](01. CSS.assets/image-20210206174355645.png)



#### 수평이면서 오른쪽 정렬하고 싶다면?

```css
	<style>
    /* li들을 나란히 배치하기 위해 inline으로 지정! */
    li {
      display: inline;
    }
    /* li의 부모인 ul을 block으로 만들어 버리니 text-align이 사용가능! */
	/* block만 text-align을 사용할 수 있다!*/
    ul {
      display: block;
      text-align: right;
    }
	</style>
</head>
<body>
  <ul>
    <li><a href="#">Home</a></li>
    <li><a href="#">Login</a></li>
  </ul>
</body>
```





![image-20210206175725453](01. CSS.assets/image-20210206175725453.png)

## Box 모델





### 크기 단위

CSS에서 사용하는 크기단위 중 가장 많이 쓰이는 단위는 아래와 같다.

1. 백분율 단위(%)

2. 배수 단위(em)

3. 픽셀 단위(px)

   

[참고] 1배 = 1em = 100%를 의미



#### 백분율 단위(%)

>  기본 크기를 100%로 놓고, 그에 대한 **상대적인 크기**를 설정



#### 배수 단위(em)

>  해당 글꼴(font)의 기본 크기를 1em으로 놓고, 그에 대한 **상대적인 크기**를 설정



#### 픽셀 단위(px)

> 스크린의 픽셀(pixel)을 기준으로 하는 **절대적인 크기**를 설정





### Box 모델

> 박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 그리고 내용(content)으로 구분



1. 내용(content) : 텍스트나 이미지가 들어있는 박스의 실질적인 내용 부분입니다.

2. 패딩(padding) : 내용과 테두리 사이의 간격입니다. 패딩은 눈에 보이지 않습니다.

3. 테두리(border) : 내용와 패딩 주변을 감싸는 테두리입니다.

4. 마진(margin) : 테두리와 이웃하는 요소 사이의 간격입니다. 마진은 눈에 보이지 않습니다.

```css
<style>
    div {
        background-color: red;
        padding: 50px;
        border: 20px solid maroon;
        margin: 50px;
    }
</style>
```



CSS에서 **height와 width 속성을 설정**할 때 그 크기가 가르키는 부분은 **내용(content) 부분만을 대상**으로 함

패딩(padding), 테두리(border), 마진(margin)의 크기는 포함되지 않음.



#### padding

>  내용(content)과 테두리(border) 사이의 간격인 패딩 영역의 크기를 설정

*  background-color 속성으로 설정하는 **배경색의 영향을 함께 받음**
* CSS를 사용하면 패딩 영역의 크기를 방향별로 따로 설정할 수 있음

![img_css_boxmodel_padding](01. CSS.assets/img_css_boxmodel_padding.png)

```css
<style>
    div.pad {
        padding-top: 50px;
        padding-right: 10px;
        padding-bottom: 30px;
        padding-left: 100px;
    }
</style>

/* 모든 padding 속성을 이용한 스타일을 아래와 같이 한 줄에 설정할 수 있음 */

<style>/* 시계방향! */
	/* top/right/bottom/left */
    .four { padding: 20px 50px 30px 50px; }
	/* top/right & left/bottom */
    .three { padding: 20px 50px 30px; }
	/* top & bottom / right & left */
    .two { padding: 20px 50px; }
	/* 모든 padding값을 같게 설정 */
    .one { padding: 20px; }
</style>
```



#### border

> 내용(content)과 패딩(padding) 영역을 둘러싸는 **테두리의 스타일**을 설정



* `border-style: dotted` : 테두리를 점선으로 설정함.

* `border-style: dashed` : 테두리를 약간 긴 점선으로 설정함.

* `border-style: solid` : 테두리를 실선으로 설정함.

* `border-style: double` : 테두리를 이중 실선으로 설정함.

* `border-style: none` : 테두리가 표현되지 않음. 레이아웃에도 영향을 미치지 않음

* `border-style: hidden` : 테두리가 레이아웃에 존재하기는 하지만 표현되지는 않음.



#### border-width

> px, em, cm 등과 같은 CSS 크기 단위를 이용하여 테두리(border)의 두께를 설정



#### border-color

> 테두리(border)의 색상을 설정



#### border의 개별설정

> 테두리의 위쪽, 오른쪽, 아래쪽, 왼쪽 부분에 대하여 개별적으로 스타일을 적용

```css
<style>
    .mixA {

        border-top-style: dotted;

        border-right-style: double;

        border-bottom-style: dotted;

        border-left-style: double;
    }
    .mixB { border-style: dotted double; }

</style>
```



#### border shorthand

> border 속성을 이용한 스타일을 한 줄에 설정할 수 있음

border 두께, border 종류, border 색깔 

```css
<style>
    .good { border: 3px solid teal; }
    .wrong { border: 5px teal; }
</style>
```



### Margin

> 테두리(border)와 이웃하는 요소 사이의 간격인 마진 영역의 크기를 설정
>
> 패딩 영역과는 달리 background-color 속성으로 설정하는 **배경색의 영향을 받지 않습니다.**



#### Margin 속성값에 auto 사용하는 이유

margin 속성값을 auto로 설정하면, 웹 브라우저가 수평 방향 마진(margin) 값을 자동으로 설정.

즉, 해당 HTML 요소의 왼쪽과 오른쪽 마진을 자동으로 설정하게 되는데 그 결과,

 해당 요소는 그 요소를 포함하고 있는 **부모(parent) 요소의 정중앙에 위치**하게 됨



단, margin auto를 사용하려면 반드시 width값을 가지고 있어야 한다.



## display

>  웹 페이지의 레이아웃(layout)을 결정하는 CSS의 중요한 속성 중 하나
>
> 해당 HTML 요소가 웹 브라우저에 언제 어떻게 보이는가를 결정



대부분의 HTML 요소는 display 속성의 기본값으로 다음 두 가지 값 중 하나의 값을 가짐



1. **블록(block)**
   * 언제나 새로운 라인(line)에서 시작하며, 해당 라인의 모든 너비를 차지
* 대표적인 block요소
     * `<div>`, `<h1>`, `<p>`, `<ul>`, `<ol>`, `<form>`

2. **인라인(inline)**

  *  새로운 라인(line)에서 시작하지 않음
  *  요소의 너비는 해당 HTML 요소의 내용(content)만큼만 차지
  *   대표적인 inline 요소
    * ​	`<span>`,`<a>`, `<img>`

3. **인라인-블록(inline-block)**
   * 해당 요소 자체는 인라인(inline) 요소처럼 동작
     * **한 줄로 늘어섬.**
   * 해당 요소 내부에서는 블록(block) 요소처럼 동작 
     * **너비와 높이를 설정**할 수 있음.
     * **margin 사용하여 여백을 지정**할 수  있음.



## position

> HTML 요소가 위치를 결정하는 방식을 설정



1. 정적 위치(static position) 지정 방식

2. 상대 위치(relative position) 지정 방식

3. 고정 위치(fixed position) 지정 방식

4. 절대 위치(absolute position) 지정 방식



### position - 1. 정적 위치(static position) 지정 방식

> position 속성값이 static으로 설정된 요소는 top, right, bottom, left 속성값에 영향을 받지 않습니다.

> 정적 위치(static position) 지정 방식은 단순히 웹 페이지의 흐름에 따라 차례대로 요소들을 위치시키는 방식입니다.



모든 HTML 요소의 position 속성의 기본 설정값은 static입니다.



### position - 2. 상대 위치(relative position) 지정 방식

> 해당 HTML 요소의 **기본 위치를 기준**으로 위치를 설정하는 방식

> HTML 요소의 기본 위치란 해당 요소가 정적 위치(static position) 지정 방식일 때 결정되는 위치를 의미



### position - 3. 고정 위치(fixed position) 지정 방식

> **뷰포트(viewport)를 기준**으로 위치를 설정하는 방식

> 웹 페이지가 스크롤 되어도 고정 위치로 지정된 요소는 항상 같은 곳에 위치하게 됨



### position - 4. 절대 위치(absolute position) 지정 방식

> 절대 위치(absolute position) 지정 방식은 고정 위치가 **조상(ancestor) 요소를 기준**으로 위치를 설정하게 됩니다.

> 하지만 위치가 설정된 조상(ancestor) 요소를 가지지 않는다면, HTML 문서의 body 요소를 기준으로 위치를 설정하게 됩니다.



#### z-index 속성

어떤 요소들은 설정된 위치 및 방식에 따라 서로 겹칠 수도 있습니다.

z-index 속성은 이렇게 겹쳐지는 요소들이 쌓이는 **스택(stack)의 순서를 설정**합니다.

스택(stack)의 순서는 **양수나 음수** 모두 설정할 수 있으며, 크기가 **클수록 앞쪽에 위치**하고 **작을수록 뒤쪽에 위치**하게 됩니다.

##### 

### 정렬(align)

> 블록(block) 타입의 요소를 정렬하기 위해서는 다음과 같은 방법을 사용할 수 있음

1. margin 속성을 이용한 가운데 정렬

2. position 속성을 이용한 좌우 정렬

3. float 속성을 이용한 좌우 정렬



#### margin 속성을 이용한 가운데 정렬

**margin 속성값을 auto**로 설정하면, 해당 요소를 감싸고 있는 **컨테이너 요소를 기준으로 수평 방향 가운데 정렬이 됩니다.**

이때 해당 요소는 **특정한 너비를 가져야** 하며, 너비를 제외한 나머지 공간은 좌우로 균등하게 나뉘어 여백으로 만들어집니다.

따라서 이 방법을 사용하기 위해서는 **반드시 해당 요소의 width 속성값을 먼저 설정해야만 합니다.**

```css
<style>
    div { width: 300px; margin: auto; }
</style>
```



<br>

---

<br>

## CSS Selector

> 선택자는 스타일을 지정할 웹 페이지의 HTML 요소를 대상으로 하는 데 사용



### 기본 선택자

1. 전체 선택자 (*),
2. 요소 선택자(h1, p, a 태그 등..)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 전체 선택자 */
    * {
      color: red;
      
    }

    /* 요소 선택자 */ /*tag로 지정가능*/
    h2 {
      color: orange;
    }

    h3, /* h3, h4 다중선택. 요소가 많아지는 경우는 이와 같이 아래로 떨어트린다. */
        /*안그럼 가로가 길어짐*/
    h4 { 
      font-size: 10px;
    }

```



3. **클래스(class) 선택자** (웬만하면 대부분 클래스 선택자를 사용하자, 우선순위 생각 안해도 되게!)

- 클래스 선택자는 마침표(.) 문자로 시작 하며 **해당 클래스가 적용된 문서의 모든 항목을 선택**

- 하나의 클래스를 만든 후 해당 클래스 하위 문서에 **재사용이 가능**하다. 
  
  - . green {} 만들어 놓고 p태그 안에 <p class="green" ~~>와 같이!
  
  

4. **아이디(id) 선택자**

- 아이디 선택자는 `#` 문자로 시작하며 기본적으로 **클래스 선택자와 같은 방식으로 사용**
- 그러나 **아이디는 문서 당 한 번만 사용**할 수 있으며 **요소에는 단일 id값만 적용 할 수 있다**
  - 클래스와 가장 크게 다른점! 클래스는 몇 번이고 다른 곳에 적용 가능
- 문서에서 동일한 아이디를 여러 번 사용해도 동작하나 그건 한 번만 사용하자는 암묵적인 약속을 깨는 것이다.



```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
      /* 클래스 선택자 */
    .green {
      color: green;
    }

    /* id 선택자 */
    #purple {
      color: purple;
    }
 </style>
</head>
<body>
  <h1 class="green">SSAFY</h1>
  <h2>선택자 연습</h2>
  <!--클래스 이름이 green box인 것이 아니라 green 과 box는 각각 다른 클래스다.--> 
  <!--클래스를 여러개 줄 수 있는데, 구분자가 공백임-->
  <div class="green box"> 
    box contents
    <div>
      <p>지역 목록</p>
      <ul>
        <li>서울</li>
        <li id="purple">인천</li>
        <li>강원</li>
        <li>경기</li>
      </ul>
    </div>
    <!--아무 글자나 필요할 때, lorem + tab하면 이와 같이 나온다.-->
    <!--만약 이 글자가 너무 많고 조금만 필요하다면 lorem3 + tab과 같이 숫자를 지정해주면 된다-->
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia laboriosam, sit hic tempore ducimus debitis! Consequuntur dolor provident, molestiae sit beatae eius rerum, dolorem ex ab quibusdam nulla temporibus minus.</p>
  </div>             
  <h3>HELLO</h3>
  <h4>CSS</h4>
</body>
</html>      
```



<br>

### **결합자**(combinators)

- **자손** 결합자
  
  - 셀렉터A  ` `(공백) 셀렉터B
  - 셀렉터A의 **모든 후손** **요소(level n) 중** 셀렉터B와 일치하는 요소 선택
  - 주의할점은 셀렉터 A는 기준점일 뿐 아무런 변화에 영향받지 않는다. 
  
  
  
- **자식** 결합자
  - 셀렉터A `>` 셀렉터B
  - 셀렉터A의 **모든 자식 요소(level 1) 중** 셀렉터B와 일치하는 요소 선택
  - 주의할점은 셀렉터 A는 기준점일 뿐 아무런 변화에 영향받지 않는다. 
  

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
/* 자식 결합자 */
    .box > p { /* 바로 아래 자식태그만을 불러오는 결합자*/
      font-size: 30px;
    }

    /* 자손 결합자 */
    .box p { /* 해당 클래스 안에 있는 모든 태그들을 선택 */
      color: blue;
    }
  </style>
</head>
<body>
  <h1 class="green">SSAFY</h1>
  <h2>선택자 연습</h2>
  <div class="green box"> 
    box contents
    <div>
      <p>지역 목록</p><!--box의 "자손"이기 때문에 파란색으로 바뀐다-->
      <ul>
        <li>서울</li>
        <li id="purple">인천</li>
        <li>강원</li>
        <li>경기</li>
      </ul>
    </div>
    <!--box의 자손이자 자식이기 때문에 파란색으로 바뀌었고 폰트도 30px로 커졌다.-->
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia laboriosam, sit hic tempore ducimus debitis! Consequuntur dolor provident, molestiae sit beatae eius rerum, dolorem ex ab quibusdam nulla temporibus minus.</p>
  </div>
  <h3>HELLO</h3>
  <h4>CSS</h4>
</body>
</html>
      
```



- **일반 형제** 결합자

  - A `~` B
  - 셀렉터 A의 **`형제 요소 중`** 셀렉터 **A뒤에 위치하는 셀렉터 B 요소를 모두** 선택
  - 주의할점은 셀렉터 A는 기준점일 뿐 아무런 변화에 영향받지 않는다. 

  

- **인접 형제** 결합자

  - A`+`B
  - 셀렉터 A의 **`형제 요소 중`** 셀렉터 **A `바로 뒤에 위치`하는 셀렉터 B요소** **하나**를 선택
  - 주의할점은 셀렉터 A는 기준점일 뿐 아무런 변화에 영향받지 않는다. 

  

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 일반 형제 결합자 A ~ B */
    /* 셀렉터 A의 형제 요소 중 셀렉터 A 뒤에 위치하는 셀렉서B 요소를 모두 선택 */
    
    /* p 요소의 형제 요소 중에서 p 요소 뒤에 위치하는 span 요소를 모두 선택 */
    p ~ span {
      color: red;
    }

  </style>
</head>
<body>
  <!-- 일반 형제 결합자 -->
  <!--<span>태그는 inline으로서 줄바꿈이 되지 않으나 뒤의 <p>태그 때문에 오른쪽이 비었음!-->
  <span>1</span>
  <!--<p>태그 앞 뒤로는 줄바꿈이 됩니다-->
  <p>2</p>
  <!--<b>태그는 inline요소로 단지 글자를 굵게 만들어줍니다 -->
  <b>3</b>
  <span>4</span>
  <b>5</b>
  <span>6</span>
</body>
</html>

```



```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 인접 형제 결합자 A + B */
    /* 셀렉터A의 형제 요소 중 셀렉터A 바로 뒤에 위치하는 셀렉터B 요소를 선택 */
    
    /* p 의 형제 요소 중 p 바로 뒤에 위치하는 p 요소를 선택 */
    p + p {
      color: red;
    }

    /* title 클래스 요소 중 title 클래스 바로 뒤에 위치하는 ul 요소 선택 */
    .title + ul {
      color: blue;
    }
  </style>
</head>
<body>
  <!-- 인접 형제 결합자 -->
  
  <p>1</p> 
  <p>2</p>
  <p>3</p>
  <div>4</div>
  <div class="title">
    <p>5</p>
  </div>
  <!--<b>만약 얘가 있으면 아래 리스트가 파랗게 안됨!!!</b>-->
  <ul>
    <li>6</li>
    <li>7</li>
    <li>8</li>
  </ul>
</body>
</html>

```



[참고]

span 태그와 div 태그는 **웹페이지 영역을 설정할 때 사용하는 태그**.

* `div`태그
  * display 속성이 block이기 때문에 박스형태의 영역을 가진다.
  * 자동으로 줄바꿈 가능

* `span`태그

  * div처럼 특별한 기능을 가지진 않음
  * display 속성이 inline이기 때문에 해당 부분만 차지하는 줄단위 영역이다.
  * 줄바꿈이 안된다

<br>

### **적용 우선순위**

1. `!important`
   - 다른 사람들의 코드에서 발견할 때 그 의미를 알 수 있는 것은 좋다.
   - 하지만 반드시 필요한 경우가 아니면 절대 사용하지 않는 것이 좋다.,
   - `!important` 는 cascading이 정상적으로 작동하는 방식을 무시하는 기능으로, CSS 스타일 오류문제를 해결하기가 어렵습니다.
2. **inline** style
   * 태그 안에 쓸 수 있는 스타일
3. **id** 선택자
   - id는 대부분의 다른 선택자보다 우선순위가 높기 때문에 다루기가 어려워 질 수 있다.
   - **대부분의 경우** **id 보다는 모두  class 선택자로 작성하는 것이 좋다**.
   - 만약 문서 내 `링크 이동`이나 `for`를 사용하는 특별한 경우에만 아이디를 사용한다.
4. **class** 선택자
5. **요소 선택자** , 태그 선택자
6. **소스 순서** (우선순위가 동일할 경우)



> 따라서 그냥 클래스 선택자만 쓰자고 하는 이유는, 이러한 우선순위를 생각하지 않고 싶어서 !



### 상속

> 텍스트 관련 요소는 상속의 영향을 받지만 박스모델에 관련한 것은 상속받지 않는다.



```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    p {
      /* 상속됨. 텍스트 관련 요소기 때문에 */
      color: red; 
      /* 상속 안됨. 텍스트 관련 요소가 아니기 때문에 */
      border: 1px solid black; /*border : 테두리, solid : 실선*/
    }

    span {
      border: 1px solid blue; /*4면이 파란색으로 랜더링 됨. 전혀 상속에 영향을 받지 않았기 때문에 */
    }
  </style>
</head>
<body><!--span태그가 자손 p태그가 부모-->
  <p>안녕하세요 <span>김싸피</span> 입니다.</p><!--김싸피는 텍스트라 상속에 영향을 받아 빨간색으로 변한다-->
</body>                                       
</html>

```



[참고]

p 태그는 block요소이며 block요소의 특징은 전체 행을 차지한다.



<br>

---

<br>

## CSS 단위

**(상대) 크기 단위**



**px** 픽셀

- 모니터 해상도의 한 화소인 '픽셀'을 기준
- 픽셀의 크기는 변하지 않기 때문에 **고정적인 단위**



**%**

- 백분율 단위
- **가변적인 레이아웃에서 자주 사용**



**em** 배수단위

* 요소에 지정된 사이즈에 상대적인 사이즈를 가짐.
  * 부모사이즈의 영향을 받는다는 말

- em은 **상속의 영향** 받음, rem은 최상위 요소(html)를 기준으로 결정됨.
- 상황에 따라 각기 다른 값을 가질 수 있다.



**rem**

- **최상위 요소인 html(root em)을  절대 단위를 기준으로 삼음.** 
- **html의 기본 폰트사이즈는 `16px`**
- **상속의 영향을 받지 않음.**

```html
<li class ="rem">1.5rem</li> <!--16의 1.5배 따라서 font-size 는 24px-->
```

- 상속에 영향을 받지 않기 때문에 **대부분의 경우 `rem` 을 많이 사용한다.**



```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .em {
      font-size: 1.5em;/*16*1.5되어 ul는 24px인 상태*/
    }

    .rem {
      font-size: 1.5rem;
    }
  </style>
</head>
<body>
  <ul class="em">
    <li class="em">1.5em</li><!--24*1.5*=36px--><!--이렇기 때문에 em을 사용하면 예상치 못한 값이 나올 때가 있다-->
    <li class="rem">1.5rem</li><!--16*1.5=24px-->
    <li>no class</li><!--얘도 상속받아 24px됨-->
  </ul>
</body>
</html>

```





#### viewport

- (스크롤을 내리지 않은 상태에서) 웹 페이지를 방문한 **유저에게 현재 보이는 웹 컨텐츠의 영역**
- viewport를 기준으로한 상대적인 사이즈
- 주로 **스마트폰이나 테블릿 디바이스의 화면을 일컫는 용어**로 사용된다.
- vw, vh



<br>

### Color



**색상 표현 단위**

1. 색상 키워드
   
   - 색상 키워드는 대소문자를 구분하지 않는 식별자로, red, blue, black처럼 특정 색을 나타낸다
   
   
   
2. RGB 색상 
   - 빨강, 초록, 파랑을 통해 특정 색을 표현
   - `#` + 16진수 표기법이나 함수형 표기법(rgb())으로 사용
   - 16진수 표기법 : `p { color: black;}`, `p { color: #000;}`, `p { color: #000000;}`
   -  함수형 표기법 : `p {color:rgb (0, 0, 0);}` ,`p {color:hsl(120, 100%, 0);}`
   - a는 alpha(투명도)가 추가된 것
   
   
   
3. HSL 색상 
   
   * 함수형 표기법 : `p {color: rgba(0, 0, 0, 0.5);}` , `p {color:hsla(120, 100%, 0.5);}`
   
   * 색상, 채도, 명도를 통해 특정 색상을 표현
   
   * a는 alpha(투명도)가 추가된 것

<br>

---

<br>

## Box Model

> 웹 디자인은 contents를 담을 box model을 정의하고 CSS 속성을 통해 스타일(배경, 폰트와 텍스트 등)과 위치 및 정렬을 지정하는 것.

- **모든 HTML 요소는 box 형태**로 되어있다.
  - 동그라미도 결국 사각형의 모서리가 잘려져서 표현되는 것임!
- 하나의 박스는 **네 부분**(영역)으로 이루어 진다.
  - margin/border/padding/content
- box model의 구성은 네방향이다.
  - 상하좌우

![제목 없음5](CSS.assets/제목 없음5.png)

<br>

## Box-sizing

* **기본적**으로 모든 요소의 box-sizing은 **content-box**이다. 

  * padding을 제외한 순수 contents영역 만을 box로 지정

    

  ![pIpI5](CSS.assets/pIpI5.png)

  그림과 같이 우리는 일반적으로 오른쪽의 모양새인 border 영역을 width로 조절하고 싶어하는 경우가 많다. 그러나 앞서 말했듯이 기본적인 box-sizing은 content가 기준으로 설정되어있다.

  

  그 경우엔 **box-sizing을 border-box 값으로 선언해주면된다!**

  ```css
  .box-sizing {
        box-sizing: border-box;
  }
  ```

  

* Margin

  * 박스의 바깥쪽.테두리 바깥의 외부여백. 

  * 배경색을 지정할 수 없다. 

  * shortand 적용가능

    ```css
    /* margin 상하좌우 조정가능*/
    .margin{
        margin-top: 10px;
        margin-right: 20px;
        margin-bottom: 30px;
        margin-left: 40px;
    }
    /* margin은 shortand를 통해 표현이 가능하다 아래의 속성은 padding도 똑같이 적용된다. */
    .margin-1{
        margin: 10px; /*상하좌우 값*/
    }
    .margin-2{
        margin: 10px 20px; /*상하 10px 좌우 20px*/
    }
    .margin-3{
        margin: 10px 20px 30px;/*상 10px 좌우 20px 하 30px*/
    }
    .margin-4{
        margin: 10px 20px 30px 40px; /*상 10px 우 20px 하 30px 좌 40px - 시계방향*/
    }
    ```

    

* Border

  * 테두리 영역

  * shortand 적용가능

    
    
    ```css
    /*border*/
    .border{
        border-width: 10px; /* 박스선의 두께 */
        border-style: dotted; /* dashed(점선), solid(실선) 등 */
        border-color: black; /* 박스선의 색깔 */
    }
    
    .border-1{ /* border의 shortand! 아래는 위와 같은 값이다. 축약어. 순서는 상관없다 */
        border-width: 10px; border-style: dotted; border-color: black;
  }
    ```
    
    

* padding

  * **테두리와 컨텐츠 사이의 여백**

  * 테두리 안쪽의 여백

  * 배경색, 이미지 지정가능

    ```css
    /*padding*/
    
    /* margin과 같이 shortand를 통해 표현이 가능하며 아래의 속성도 똑같이 적용된다. */
    .padding-1{
        padding: 10px; /*상하좌우 값*/
    }
  .padding-2{
        padding: 10px 20px; /*상하 10px 좌우 20px*/
    }
    .padding-3{
        padding: 10px 20px 30px;/*상 10px 좌우 20px 하 30px*/
    }
    .padding-4{
        padding: 10px 20px 30px 40px; /*상 10px 우 20px 하 30px 좌 40px - 시계방향*/
    }
    ```
    
    

* content

  * 박스 안의 내용
  * 글이나 이미지 등 요소의 실제 내용



#### 04_box_model.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box1 {
      width: 500px;
      border-width: 10px; /*박스선의 두께*/
      border-style: dotted; /* dashed : 점선, solid : 실선 */
      border-color: palevioletred; /*박스색깔*/
      padding-left: 50px; /*왼쪽의 박스테두리와 컨텐츠 사이 여백*/
      margin-bottom: 30px; /* 박스의 바깥쪽, 외부 박스들과의 여백*/
    }

    .box2 {
      width: 500px;
      border: 2px solid black;/* shortand */
      padding: 20px 30px; /*상하 20px 좌우 30px. 이렇게 margin과 똑같이 상하좌우를 움직일 수 있다*/
      margin: 0 auto; 
      color: white; /*글자색*/
      text-align: center; /*글자 가운데정렬*/
      /*상하는 margin을 0으로, 값을 주지 않았고 좌우는 auto를 준 것이다 따라서 중앙정렬이 된다*/
    }
  </style>
</head>
<body>
  <div class="box1">BOX1</div>
  <div class="box2">BOX2</div>
</body>
</html>
```

<br>



#### 마진 상쇄

![마진상쇄](CSS.assets/마진상쇄.png)
* block의 top, bottom인 경우..  즉 두 개의 박스가 위아래로 정렬되어 있을 때 서로 맞물리는 부분(윗 박스의 bottom 아래 박스의 top) 부분 둘 다 margin값을 가지고 있다면, 마진상쇄가 일어난다.
- 마진상쇄란 **더 큰 쪽의 margin만유효**하게 되고 **나머지 margin값은 상쇄**되는 경우를 말한다.
- 예를들어 위쪽 박스의 margin bottom이 10px이고 아래 박스의 margin-top이 60 px이면 우리가 생각하기엔 둘 사이의 거리가 70px이 되어야 한다고 생각하겠지만 마진상쇄가 일어나 둘 사이 거리는 결과적으로 60px이 된다.



## Display

> display CSS 속성은 요소를 **블록**과 **인라인 요소** 중 어느 쪽으로 처리할지와 함께 **자식 요소를 배치할 때 사용할 레이아웃을 설정**한다.

**block**

* 대표적인 블록레벨 요소 : div / ul, ol ,li / **p** / hr / form 태그 등

* 기본적으로 **가로 영역을 모두 채우며**(기본 너비의 100%) block요소 다음에 등장하는 태그는 

  **줄바꿈이 된 것 처럼 보인다.**

- 쌓이는 박스
- 요소는 블록 요소 상자를 생성하여 일반 흐름에서 요소 앞뒤에 줄 바꿈을 생성한다.
- 블록 레벨 요소안에 인라인 레벨 요소가 들어갈 수 있다.



- **block 정렬** : 안의 마진값이 중요하기 때문에 **마진 값으로 정렬**한다.
  - margin-right: auto;
  - margin-left: auto;
  - margin-right: auto;
  - margin-left: auto;

<br>

**inline**

* 대표적인 인라인 레벨요소 : span / a / img / input, label / b, em, i, strong 등

* span 태그, b 태그, i 태그, a 태그 

- **줄바꿈이 일어나지 않는** 행의 일부 요소
- 글자나 문장에 효과를 주기 위해 존재하는 단위
- **가로 영역을 모두 차지하지 않고 해당 content 너비만큼만 차지**
- **width, height, margin-top, margin-bottom을 지정할 수 없음**
- 상하 여백은 line-height로 지정
- width   설정이 불가능



- **inline정렬** : 요소값이 중요하기 때문에 텍스트로 정렬
  - text-align : left;
  - text-align : right;
  - text-align : center;

<br>

**inline-block**

* block과 inline의 중간형태
* 줄바꿈 가능하지만 크기지정 불가능	

- inline 처럼 텍스트 흐름대로 나열 및 **해당 콘텐츠 부분만 차지**함, block처럼 박스 형태이기 때문에 **block 속성 사용가능** (width, height, margin 속성)

  

<br>

#### display: none    VS    visibility: hidden

**display: none**

- 해당 요소를 화면에서 사라지게 하며 요소의 공간조차 사라지게 한다.

- 따라서 아래에 다른 박스가 있었다면 해당 박스가 치고올라와 새롭게 자리를 차지한다

- 06_display.html 참조

  

**visibility: hidden**

* 해당 요소를 화면에서 사라지게는 하나 공간은 사라지지 않는다.
* 06_display.html 참조



<br>

---

<br>

# CSS Position

> CSS Position 요약 (for 광주 2반)

* `position` 속성을 통해 **문서 상에 요소를 배치하는 방법**을 지정한다.

* `top`, `right`, `bottom`, `left` 속성을 통해 **요소의 최종 위치**를 결정한다.

* 사용법은 간단하다.
  1. 기준을 잡는다.  (예- `position: relative;`)
  2. 이동시킨다. (예- `top: 50px;`)

[참고]

**block** : h1이나 h2는 bolck속성 가져서 너비 100% 차지한다. 그래서 자동줄바꿈한 것 처럼 보인다

**in -line** : span태그는 해당 부분 너비만을 가진다



---



## Position 속성

> 요소를 옮기려면 일단 위치를 옮길 기준점을 잡는다.

| 값       | 의미                             |
| -------- | -------------------------------- |
| static   | 기준 없음 (배치 불가능 / 기본값) |
| relative | 요소 자기 자신을 기준으로 배치   |
| absolute | 부모(조상) 요소를 기준으로 배치  |
| fixed    | 뷰포트 기준으로 배치             |
| sticky   | 스크롤 영역 기준으로 배치        |



1. static (기본 위치)

   - 모든 태그의 기본
   - 태그의 default 값
   - 웹페이지의 좌측상단이 기준점이 된다.

   

2. relative (상대 위치)

   - 기본 위치(static)를 기준으로 좌표 속성을 사용해 위치 이동
   - 웹페이지의 좌측상단이 기준점이 된다.
   - **다른 요소들의 위치에 영향을 주지 않는 특징**
   - 따라서 잘못 배치하면 글자나 상자가 겹칠 수 있다.
   - `hr태그`가 있으면 해당 코드 아래부분 박스의 position이 relative로 설정되었을 땐 `hr 선 아래가 기준점`이 된다.
   - `07_position.html`참고



3. absolute (절대 위치)

   - static 이 아닌 **부모/조상 요소를 기준**으로 좌표 속성 만큼 이동
   - **부모 요소**를 찾아가고 나아가 **없다면 body에 붙는다.**
   - `absolute`는 원래 위치해 있었던 **과거 위치에 있던 공간은 더 이상 존재하지 않는다는 점**이 특징이다.
   - 대체 언제 쓸까?
     - 페이지의 다른 요소의 위치와 간섭하지 않는 **격리된 사용자 인터페이스 기능**을 만들 수 있다.
     - 팝업 정보 상자 및 제어 메뉴, 롤오버 패널, 페이지 어느 곳에서나 끌어서 놓기할 수 있는 유저 인터페이스 페이지 등



4. fixed (고정 위치)

   - 부모/조상 요소와 관계없이 **브라우저의 viewport를 기준**으로 좌표 속성 만큼 이동
   - 스크롤을 내리거나 올려도 화면에서 사라지지 않고 **항상 같은 곳에 위치**

<br>



---



## Top, Bottom, Left, Right 속성

> 기준점을 잡았으면 다음 네 가지 속성을 이용해서 요소의 위치를 옮길 수 있다.
>
> 요소의 Position 기준에 맞춰 위쪽, 아래쪽, 왼쪽, 오른쪽에서의 거리를 설정한다.

* top : 요소의 position 기준에 맞는 위쪽에서의 거리(위치)를 설정
* bottom : 요소의 position 기준에 맞는 아래쪽에서의 거리(위치)를 설정
* left : 요소의 position 기준에 맞는 왼쪽에서의 거리(위치)를 설정
* right : 요소의 position 기준에 맞는 오른쪽에서의 거리(위치)를 설정





---



## Relative

> 요소를 일반적인 문서 흐름에 따라 배치한다.
>
> **요소 자기 자신의 원래 위치(static 일 때의 위치)를 기준으로 배치**한다.
>
> - 원래 위치를 기준으로 위쪽(top), 아래쪽(bottom), 왼쪽(left), 오른쪽(right)에서 얼마만큼 떨어질 지 결정한다.
> - 위치를 이동하면서 다른 요소에 영향을 주지 않는다.
> - 문서 상 **원래 위치가 그대로 유지**된다.

```html
<div class="grand-parent">
  <div class="parent">
      <div class="child">1</div>
      <div class="child relative">2</div>
      <div class="child">3</div>
  </div>
</div>
```

```css
.grand-parent {
    /* 박스 스타일링 */
    width: 500px;
    height: 500px;
    border: 5px dotted lightsalmon;
    padding: 50px;
}

.parent {
    /* 박스 스타일링 */
    width: 500px;
    height: 500px;
    border: 5px dotted lightslategray;
}

.child {
    /* 박스 스타일링 */
    width: 150px;
    height: 100px;
    border: 3px dotted crimson;
    border-radius: 12px;
    background: lightyellow;

    /* 텍스트 정렬 */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 30px;
}

.relative {
    position: relative;
    left: 100px;
    top: 80px;
}
```



---



## Absolute

> 요소를 일반적인 문서 흐름에서 제거한다.
>
> **가장 가까운 위치에 있는 조상 요소를 기준으로 배치**한다.
>
> - 조상 요소 위치를 기준으로 위쪽(top), 아래쪽(bottom), 왼쪽(left), 오른쪽(right)에서 얼마만큼 떨어질 지 결정한다.
> - 조상 중 Position을 가진 요소가 없다면 초기 컨테이닝 블록를 기준으로 삼는다. (static을 제외한 값)
> - 문서 상 **원래 위치를 잃어버린다.** (아래에 있는 div가 해당 자리를 차지한다)



## Fixed

> 뷰포트를 기준으로 삼고 싶은 경우?



우선, 조상 Position 없음 & 자식 absolute 이렇게 말고 fixed를 써야하는 이유?

absolute를 사용하여 똑같이 구현할 수 있지만  absolute는 조상위치 기준점을 삼으므로 viewport를 기준점으로 삼으려면 fixed삼는게 올바른 방식이다.

안쪽에 들어가있는 div에 뷰포트를 주고싶을 때 div를 absolute를 주어야하는데...해당 div윗부분 전부 다 포지션이 없어야 하는데.. 이는 언제 바뀔지 모르는 상황에서 사용하기 애매하다. 이건 편법일 뿐이다.



`뷰포트를 기준점 삼고싶으면 명시적으로 fixed라고 표시한다`

* 요소를 일반적인 문서흐름에서 제거한다. 페이지 레이아웃에 어떠한 공간도 배정하지 않는다
* 뷰포트를 기준점으로  붙어있다.(==화면에 붙어있다)
  * 쇼핑몰 우측 하단에 있는 '상단으로 바로가기' 버튼





### 부모 relative & 자식 absolute

> Parent에게 Position 값이 있는 경우, **Parent의 위치를 기준점으로 삼는다.**



```html
<div class="grand-parent">
  <div class="parent">
      <div class="child">1</div>
      <div class="child absolute">2</div>
      <div class="child">3</div>
  </div>
</div>
```

```css
.parent {
    /* ... */
    /* ... */

    position: relative;
}

.absolute {
    position: absolute;
    bottom: 5px;
    right: 5px;
}
```



### 조상 relative & 자식 absolute

> Grandparent에게 Position 값이 있는 경우, **한 단계 올라가서 Grandparent의 Position 값을 찾아서 기준점으로 삼는다.**





### 조상 Position 없음 & 자식 absolute

> 부모, 조상 전부 뒤져봐도 Position 값이 없는 경우(Parent, Grandparent, body 태그, html 태그까지), window 객체의 **뷰포트**를 **기준점**으로 삼는다.



[참고]

뷰포트 : 디바이스 마다 다른, 사용자들이 보고있는 화면





